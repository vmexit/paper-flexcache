\section{Characterizing Workload Access Patterns}
\label{s:access-patterns}

This section presents how \sys overcomes the first gap of the prior 
adaptive algorithms by proposing an novel and fine-grained 
pattern characterization approach.
%
We first discuss \XXX{This section shows how \sys characterizes access patterns with a few representative examples.}

\subsection{Fine-Grained Access Pattern Characterization}

To capture the diverse access patterns, \sys characterizes access patterns in fine-grained at the object-level, thereby departing from the prior coarse-grained subtrace-level approaches.
%
As shown in \S\ref{}, \syss approach is more flexible, \XXX{covering} many more access patterns. 
%
There are three rationales behind \syss characterization approach, as detailed next. 
%

\PN{Object-level characterization.}
%
The first rationale is that classifying subtraces into fixed set of simple access patterns, as employed in prior work, is inherently difficult in characterizing the wide spectrum of real-world access patterns. 
%
Therefore, \sys characterizes access patterns at the object level, the finest granularity possible.
%
given a sequence of accesses, \sys characterizes its pattern by evaluating each accessed object with specific metrics~(specifically, \hotness and \popularity, as detailed next).
%
Therefore, the access pattern of a workload is characterized by the distribution of the metrics of all the accessed patterns. 

\PN{Characterization metrics: \hotness and \popularity.}
%
The second rationale is that object metrics should reflect access locality, as this is essential reason why caching works. 
%
Following prior work~\cite{}, \sys uses two common proxies, recency and frequency, to approximate locality.
%
% The second rationale lies in deciding the specific metrics for characterizing each object. 
% %
% Our observation is that, fundamentally, the effectiveness of caching relies on the temporal and spatial locality.  
% %
% A cache eviction algorithm largely depends on how well it exploits temporal locality (as spatial locality is often addressed by techniques like prefetching). 
% %
% Hence, following prior work~\cite{}, \sys uses two popular proxy, recency and frequency to approximate temporal locality.  
% %

\DZ{Have we acheived this?}
However, unlike prior work, \sys decouples recency and frequency into two independent metrics to improve classification accuracy. 
%
Specifically, \sys divides a trace into epochs, each containing as many unique object accesses as the cache size. 
%
\sys measures object recency using \textit{\hotness}, the number of times an object is accessed in the current epoch.
%
It measures frequency using \textit{\popularity}, the number of times an object was accessed across earlier epochs, excluding the current one.

\PN{Using cache size to decide thresholds}
%
The third rationale is that characterization must account for cache size, since the same access sequence can produce different patterns under different cache sizes.
%
\DZ{@Liujia, give a simple example here. Avoid using the churn --> LFU example if possible as that's boring.}

\sys accounts for cache size with two steps. 
%
First, \sys introduces a threshold for both \hotness and \popularity to classify objects.  
%
In the \hotness dimension, an object is marked as \hot or \cold based on whether its hotness is above or below the hotness threshold.
%
Likewise, in the \popularity dimension, an object is marked as \popular or \rare depending on whether its popularity exceeds or gets below the popularity threshold. 

Next, the thresholds are dynamically adjusted by considering cache sizes.
%
Suppose that the cache size is $S$, the \hotness (and \popularity) threshold is the \hotness (and \popularity) count of the $S$-th most \hot (and \popular) object. 
%
The reason is intuitive: the cache should ideally hold the $S$ most \hot and \popular objects to maximize hit rate. 
%
Figure~\ref{} shows an example. 


\PN{Putting it together.}
%
\sys characterizes workload access pattern by classifying each accessed object into one of the four types based on its \hotness and \popularity: \hot-\popular, \hot-\rare, \cold-\popular, and \cold-\rare.
%
% The characterization considers cache sizes by using it to adjust the thresholds for \hotness and \popularity.
The cache size decides the thresholds for \hotness and \popularity. 

\subsection{How \sys Characterizes Access Patterns}
%
\PN{The primitive access patterns.}
%
An \textit{LRU-friendly} pattern is one in which most objects are \hot~(\hot-\popular or \hot-\rare), whereas an \textit{LFU-friendly} pattern is one in which most objects are \popular~(\hot-\popular or \cold-\popular).
%
A \textit{Churn} pattern \XXX{}
%
A \textit{Scan} pattern consists of all \cold-\rare objects.
%
\XXX{\lirs~\cite{} proposes a recency-based pattern IRR by reuse interval of objects.
}
\XXX{The one-hit wonders are also \cold-\rare objects.}
\XXX{relative concept.}
% an \textit{LFU-friendly} pattern occurs frequently lasting many phases as \hot-\popular type, and an \textit{LRU-friendly} pattern trends to reaccess recently, which has a concentrated access in a small number of phases as \hot-\rare type.
% %
% A \textit{Churn} pattern repeats in many phases with equal probability, and if the phase size matches the repeated periods, it is \cold-\popular type.
% %
% A \textit{Scan} pattern appears only once in a phase as \cold-\rare type.
% %

