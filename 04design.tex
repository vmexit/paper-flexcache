\section{The \sys Design}
\label{s:design}
Inspired by \autoref{s:epoch-hotness}, we presents \sys, a epoch- and hotness-based adaptive cache eviction algorithm that covers access patterns space reliably.
%
This section presents \sys's design goals and challenges~(\autoref{ss:design-goals-and-challenges}), an overview of \sys~(\autoref{ss:overview}), and concludes with a discussion~(\autoref{ss:discussion-and-limitations}).

\subsection{Design Goals and Challenges}
\label{ss:design-goals-and-challenges}
We design \sys to meet the following goals and resolve the corresponding challenges.

\textbf{Online patterns identification.}
%
To receive a timely and accurate access pattern, \sys works in an online optimization with FIFO queues and a sketch for epoch classification~(\autoref{ss:adaptive-epochs}), hotness distribution for hotness classification~(\autoref{ss:hotness-during-epochs}), and adjusts patterns with cache size.

\textbf{Algorithm for patterns.}
%
To reduce the analysis overhead, \sys integrates with the online pattern identification.
%
\sys also separates function parts to handle different characteristics of patterns and leverages a suspicious area to confirm the changes of data types for reliability.

\textbf{Efficiency and scalability.}
%
An excellent eviction algorithm should be efficient and scalable.
%
\sys has a high hit ratio to reduce the bandwidth consumption to the backend storage.
%
\sys updates metadata and types when needed to reduce operations for high throughput, and it leverages FIFO queues and a sketch for lock-free implementations to improve scalability.

\newpage
\subsection{\sys Overview}
\label{ss:overview}

\textbf{\sys components.} 
%
As shown in figure~\ref{fig:patternspace}, \sys has three queues~(\ABB{F}, \ABB{M}, and \ABB{S}) and three auxiliary structures~(\ABB{G}, \ABB{K}, and \ABB{H}).
%
The filter~(\ABB{F}), main~(\ABB{M}), and suspicious~(\ABB{S}) FIFO queues store metadata and values, while the ghost queue~(\ABB{G}) is a FIFO queue store only metadata.
%
Extra metadata includes a \textit{hotness counter}, a \textit{epoch counter}, a \textit{suspected flag}, and a \textit{access pattern field}.
%
The sketch~(\ABB{K}) records the number of epoches data appeared in the past.
%
The hotness recorder~(\ABB{H}) has \textit{a hotness threshold field} and an array for the \textit{hotness distribution}.

\sys uses \ABB{F} to filter out \textbf{infrequent-ephemeral} data quickly and \ABB{K} to find \textbf{infrequent-persistent} data.
%
\ABB{G} suggests \textbf{frequent-ephemeral} data due to space limitations, and \ABB{M} holds most \textbf{frequent-persistent} data.
%
\sys makes educated guesses about some patterns changes and moves them to \ABB{S} for observation.
%
\ABB{S} also checks data from \ABB{M} at the end of an epoch to confirm their patterns.

\textbf{Epoch awareness.} 
%
All the queues (\ABB{F}, \ABB{M}, \ABB{S}, \ABB{G}) are FIFO-based with a fixed size to keep relative access order for epoch awareness.
%
\ABB{F}, \ABB{M}, and \ABB{S} store epoch for data in the cache, while \ABB{G} contains epoch information for data not in the cache.
%
\sys maintains data for at least one epoch.
%
At the end of an epoch, \ABB{K} records data appears in the past epochs with a forget function, and \sys increases the \textit{epoch counter} and decreases the \textit{hotness counter} if it is still in the cache.

\textbf{Hotness awareness.}
%
In \ABB{H}, the \textit{hotness distribution} maps the hotness counter values with the number of items in the cache~(\ABB{F}, \ABB{M}, \ABB{S}, and \ABB{G}) that have the corresponding value.
%
\sys adjusts the \textit{hotness threshold field}, assuming all the hotness data are stored in the cache.
%
Therefore, once the hotness counter of an item changes, \sys updates the \textit{hotness distribution}, by decreasing the number of the old value and increasing the number of the new value, and acumulates the number of items from the hottest, until reaching the cache size to set the new \textit{hotness threshold field}.

\textbf{Workflow.}
%
When cache hit occurs in \ABB{F}, \ABB{M}, or \ABB{S}, \sys increases the data's hotness counter by one (up to a predefined maximum) and updates \ABB{H} as discussed accordingly.
%
The data type is then re-evaluated based on the current hotness threshold.
%
In the case of a cache miss, if the data is not present in \ABB{G}, \sys inserts it into \ABB{F}; otherwise, it increases the hotness counter, updates \ABB{H}, and reassesses the data type.
%
Depending on the result, \sys promotes the data to \ABB{M} if identified as \textit{frequent-ephemeral}, or to \ABB{S} with \textit{suspected flag} if identified as \textit{infrequent-ephemeral}.

When the cache is full, \sys will evict data and manage data movement among the queues based on their access patterns.
%
When \ABB{F} exceeds its size limit, \sys moves \textit{frequent-ephemeral} data to \ABB{M} and \textit{infrequent-ephemeral} data to \ABB{G}.
%
If data is evicted to \ABB{G}, \sys also compares its epoch count in \ABB{K} with data in the tail of \ABB{S}, making an educated guess as to whether the data may be \textit{infrequent-persistent}.
%
Data suspected to belong to this category are placed into \ABB{S} for verification, marked with a \textit{suspected flag}.
%
When \ABB{G} is full, \sys evicts the tail data, updates \ABB{H}, and records epoch information in \ABB{K}.
%
When \ABB{M} exceeds its size limit, \sys moves data to \ABB{S} for pattern verification.

\ABB{S} serves as a verification area for data from \ABB{M} and suspected data from \ABB{F} and \ABB{G}.
%
If suspected data is accessed during observation, \sys confirms its pattern and promotes it to \ABB{M}; otherwise, \sys evicts it.
%
For data from \ABB{M}, \sys records its epoch information in \ABB{K}.
%
If its \textit{hotness counter} is zero, \sys evicts it; otherwise, \sys decreases the counter, updates \ABB{H}, increases its \textit{epoch counter}, and moves it to the head of \ABB{M} for another epoch.


\textbf{Handling different access patterns.}

\textbf{Workflow of \sys.}
%
\BC{1} For epoch analysis, \ABB{K} records all the data movement out of \ABB{F} and checked data by \ABB{S} with a forget function.
%
\BC{2} For hotness analysis, \sys updates the hotness distribution and adjust the hotness threshold field whenever a cache hit or eviction occurs.
%
We will discuss the epoch and hotness in \sys later in details.

For the data in \ABB{F} and \ABB{G}, \BC{3} All new data not in the cache are inserted into \ABB{F}.
%
\BC{4} \sys does not move data in \ABB{F} directly when its type changes.
%
Instead, \sys moves \textit{frequent-ephemeral} data to \ABB{M} and \textit{infrequent-ephemeral} data to \ABB{G} when \ABB{F} exceeds its size limit.
%
\BC{5} If hit occurs in \ABB{G}, \sys promotes \textit{frequent-ephemeral} data to \ABB{M} and evicts data when \ABB{G} exceeds its size limit.
%
\BC{6} \sys makes educated guesses about \textit{infrequent-ephemeral} data: when a hit occurs in \ABB{G}, it assumes the data belongs to the \textit{frequent-ephemeral};
%
when data is evicted from \ABB{F}, if it have been recorded in \ABB{K} for enough times, execeeding a threshold and more than the last data in \ABB{S}, it assumes to be \textit{infrequent-persistent}.
%
\sys places the suspected data into \ABB{S} for verification, while retaining its metadata in \ABB{G} for epoch analysis.
%

For the data in \ABB{M} and \ABB{S}, \BC{7} when \ABB{M} exceeds its size limit, \sys moves data in \ABB{M} to \ABB{S} for type verification.
%
\BC{8} In \ABB{S}, \sys checks whether data from \ABB{M} is accessed again in the last epoch.
%
If hit occurs, \sys confirms it as \textit{persistent} data and promotes it to \ABB{M}; otherwise, reduces its hotness counter, evicting it if the counter reaches zero.
%
\BC{9} For suspected data, \sys checks whether it is accessed again in \ABB{S} as an observation window, and promotes it to \ABB{M} if hit occurs; otherwise, it is evicted from \ABB{S}.

\textbf{epochs Discussion.}
%
\sys integrates epoch analysis with cache size and maintains data in the cache for at least one epoch.
%
\ABB{M} occupies most of the cache space, \ABB{F} and \ABB{S} are small part of the cache, and \ABB{G} has the same number of metadata as the total size of other queues.
%
All the queues in \sys are FIFO-based which maintains the relative access order as discussed in \autoref{ss:adaptive-epochs}.
%
Therefore, data in \ABB{M} or \ABB{G} experiences a epoch size with a footprint approaching cache size, and we discuss the workflow between the queues for each classification.

As shown in figure~\ref{fig:epochflow}, there are two epoch flows for fixed classification data: \textit{data-based} and \textit{metadata-based}.
%
(1) The \textit{infrequent-ephemeral} data experiences a \textit{metadata-based} epoch in \ABB{F} and \ABB{G}, and if there is no type change, it is evicted from \ABB{G} at the end of the epoch~(\BC{3},\BC{4},\BC{5}).
%
(2) The other types of data experience a \textit{data-based} epoch in \ABB{M} and \ABB{S}, and \sys examins its type in \ABB{S} at the end of the epoch~(\BC{7},\BC{8}).

When type transitions or guess happen, there are three epoch flows.
%
(1) For certainty transitions, data moves to the \ABB{M} from \ABB{F} or \ABB{G} and enjoys a full epoch as \textit{frequent} data~(\BC{4},\BC{5}).
%
(2) For suspected transitions, if it is a right guess, data moves to \ABB{M} from \ABB{S} and enjoys a full epoch as \textit{frequent} data; otherwise, it is evicted from \ABB{S}~(\BC{6},\BC{9}).
%
(3) The false guess has a duplicate metadata in \ABB{G}~(\BC{6}), at least experiencing a full epoch as \textit{infrequent} data in \ABB{G}, which has multiple chances to be guessed or promoted.

\ABB{K} collects epoch information beyond a epoch flow in the cache.
%
There are two major epoch flows in \sys for \ABB{M} and \ABB{G}, and data will experience at least one epoch in them.
%
Therefore, a basic version of \ABB{K} only needs to record data movement out of \ABB{M} and \ABB{G}.
%
While \ABB{K} targets for \textit{infrequent-persistent} data, to reduce the influence of other types, \ABB{K} delays recording data out of \ABB{M} and records data checked by \ABB{S}.
%
To reduce the influence of suspected data, \ABB{K} ignores data out of \ABB{G} and records data into \ABB{G}.
%
Finally, \ABB{K} conservatively proposes \textit{infrequent-persistent} data and leverages a forget function to forget old records beyond many epochs.


\textbf{Hotness Discussion.}
%
\sys also integrates hotness analysis with cache size and adjust the hotness threshold field adaptively.
%
The hotness distribution records the hotness counter of all data in the cache, including metadata, in an array.
%
As discussed in \autoref{ss:hotness-during-epochs}, hotness threshold is a portion of the hottest data in the hotness distribution.
%
In \sys, the target portion is the proportion of number of data stored in \ABB{M}, \ABB{S}, and \ABB{F} to the total amount of metadata data in cache.

\sys have an online hotness analysis.
%
In \sys, the hotness distribution represents the distribution of all hotness counter values, and \sys dynamically adjusts the hotness threshold based on this distribution and the target portion.
%
Whenever a cache hit occurs, \sys increases the hotness counter of the corresponding data, which has a maximum value.
%
Then, \sys updates the data type based on the hotness threshold if hit occurs in \ABB{F} or \ABB{G}. 
%
\sys only decreases the hotness counter when the object is evicted from \ABB{G} or aged in \ABB{S}.

\textbf{Type identification.}
%
To reduce the operation overhead for efficiency, \sys only updates data type when needed, eventhough online algorithm can identify data type timely.
%
Therefore, type identification happens before data movement between queues or hit occurs in \ABB{G}.
%
All new data inserted into \ABB{F} is treated as \textit{infrequent-ephemeral} type initially~(\BC{3}).
%
If the hotness counter of an object in \ABB{F} or \ABB{G} exceeds the threshold, the \textit{infrequent-ephemeral} data becomes \textit{frequent-ephemeral} type~(\BC{4},\BC{5}).
%

Almost all type transitions happen in \ABB{S}, while \ABB{M} only stores data for epoch analysis~(\BC{7}).
%
\ABB{S} does not change \textit{frequent-persistent} and \textit{infrequent-persistent} data from \ABB{M} and only decreases their hotness counter when aged~(\BC{8}).
%
If \textit{frequent-ephemeral} data from \ABB{M} is alive in the new epoch, \sys transits it to \textit{frequent-persistent} type~(\BC{8}).
%
For suspected data from \ABB{F} and \ABB{G}~(\BC{6}), if hit occurs in \ABB{S}, \sys confirms the data type from \textit{infrequent-ephemeral} to \textit{infrequent-persistent} or to \textit{frequent-ephemeral} type~(\BC{9}).
%
\sys evicts data without access for many epochs based on hotness counter and does not change their types.


\textbf{Implementation}
The FIFO-based queues have different implementations for \textit{find}, \textit{delete}, \textit{insert}, and \textit{eviction} operations to improve efficiency and scalability.
%
It is efficient to operate \textit{insert} and \textit{eviction} operations in the head or tail of the queue.
%
However, it is impossiable to scan the whole queue for \textit{find} and \textit{delete} operations.
%
Therefore, \sys decouples the storage logic and evcition algorithm logic as prior work~\cite{}.
%
The storage logic leverages a hash table to index the position of data, which is efficiency and scalable.

A FIFO-based queue in evcition algorithm logic has linked-list or ring-buffer implementation.
%
With linked-list implementation, linked-list pointers can intergate with storage logic with a hook portabliy, but have to manage pointers with atomic operations, which reduces scalability.
%
Ring-buffer implementation is more scalable with less atomic operations, but it requires extra space for the buffer, which also wastes space when workload has many \textit{delete} operations.

\ABB{G} can be further simplified for efficiency and scalability.
%
Since \ABB{G} will not delete data except for eviction~(\BC{6}), it has less operations and space overhead in both linked-list and ring-buffer implementations.
%
An accurate \ABB{G} can be used for prefetching~(\TODO{ref}), while a lossy \ABB{G} can instead evcition algorithm logic with a timestamp and fingerprint field.
%
For example, a fingerprint has 4 Byte of hashed key and a timestamp has 4 Byte of insertion time.
%
\sys stores a scope of timestamps based on the epoch size and evicts data beyond the scope.

\ABB{K} with a forget function has many candidate implementations, which are scalable.
%
A Counting Bloom Filter (CBF)~\cite{} increases all the indexed counters when recording data with less space overhead and false positives.
%
A Count-Min Sketch (CMS)~\cite{} only increases the minimum indexed counter, which reduce false positives.
%
A sliding window sketch~\cite{} provides various forget functions, which separates \ABB{K} into many sub-sketches for different epochs.
%
At the beginning of a new epoch, it inserts records into a new sub-sketch and forgets the oldest sub-sketch beyond many epochs.
%
To improve the space utility, \ABB{K} is a sketch and clean a fraction of counters with a forget function periodically.
%
A fine-grained forget function ages counters one by one after a fixed number of inserations, which averages the operation overhead for efficiency.


\subsection{Discussion and Limitations}
\label{ss:discussion-and-limitations}
\textbf{Online Adaption.} \sys integrates online epoch and hotness analysis with cache size to adapt to various access patterns.
%
With different cache sizes, data experiences different epoch sizes in \ABB{M} and \ABB{G}, and hotness threshold changes with epoch.
%
Therefore, to adjust the epoch size and hotness threshold, it is convenient to change the size of \ABB{M} and \ABB{G} and the target portion.
%

However, there is not a proper theoretical model to guide the adjustment of components size with changed types.
%
There are some theoretical models for fixed classification into different components, which generate the MRC of each components and optimize the overall hit ratio~\cite{}.
%
Therefore, we leave the adaption of \sys to future work and use fixed sizes for all the components in this paper.
%
The \ABB{F} is 10\% of the cache size, \ABB{S} is 5\%, and \ABB{M} is about 85\%.
%

\textbf{Computation overhead.} 
%
\sys does not introduce extra computation overhead as prior work~\cite{}.
%
With a maximum value for hotness counter and delayed type checking, \sys thus performs negligible metadata updates on cache hits.
%
When cache miss occurs, \sys checks data in \ABB{S} gradually as prior work~\cite{}, and hotness distribution can be updated lock-free using atomic operations.
%
Hash function is used widely in basic operations and \ABB{K}, while xxHash provides 31.5 GB/s operations~\cite{}, which is not a bottleneck for the performance.
%

\textbf{Space overhead.} 
%
\sys introduces space overhead for metadata and components \ABB{G} and \ABB{K}.
%
\sys uses 3 bits to store the access frequency, which is sufficient for most workloads.
%
With a bit for suspection, the 4 bits can often be piggybacked on the unused flags in the metadata.
%
\ABB{G} stores the same number of data (only metadata) as the total size of other queues.
%
Assuming the average object size is 4KB, and the object id is 4 bytes, \ABB{G} uses 0.1\% of the total memory space.
%
In Count-Min Sketch~\cite{}, with a false positive error rate of 1\% and error range of 1, a 8-epoch \textit{infrequent-persistent} data requires about 3 bits for record.
%
\ABB{K} comsumes about 0.13\% of the total memory space.
%, and there are 40.5 bits for each object.
%the space amplification is about 13.5.

\textbf{Prefetching.} \sys can prefetch in \ABB{G} for \textit{infrequent-empheral} data or integrate with other prefetchers.
%
A typical \textit{Churn} pattern has a sequence of accesses, while \ABB{K} would not cover all of them for limited space.
%
As discussed in \autoref{ss:overview}, \ABB{G} also keeps the relative access order for epoch awareness, which provides an opportunity for prefetching.
%
When continueous data is accessed in \ABB{G}, \sys can prefetch the following data in the sequence to \ABB{F} and maintain metadata in \ABB{G}.
%
If prefetching hits in \ABB{F}, it would be treated as normal data; otherwise, \sys will evict it.
%
When \sys intergates with other prefetchers, \sys can leverage the prefetcher to insert data into \ABB{F} directly, which will not affect other queues.

\textbf{Limitations.}
%
On workloads with tiny objects, linked-list implementation of FIFO queues would introduce high space overhead for pointers.
%
\ABB{G} and \ABB{K} would also introduce high space overhead for metadata, and \sys needs to limit their sizes.
%

\textbf{Adversarial workloads for \sys.}
%
\sys highly relies on epoch and hotness analysis to identify access patterns.
%
(1) Workloads with large reuse which apporaches the epoch size are challenge for epoch analysis.
%
The large reuse would have many hits in \ABB{G} rather than \ABB{M} for the first epoch in \sys, and it will be evicted by suspected data in \ABB{S} at the end of the epoch, leading to many misses.
%
(2) Workloads with greatly changed hotness distribution are challenge for hotness analysis.
%
In this case, the hotness threshold would change frequently, and \ABB{K} takes time to learn it. 
%


Other algorithms also suffer from these workloads, and large cache size or prefetcher can mitigate the influence.
%
Algorithms with a small filter queue~(S3-FIFO~\cite{}, 2Q~\cite{}) also evict data to ghost queue, leading to misses.
%
Algorithms without a sketch~(ARC~\cite{},CACHEUS~\cite{}) also discard useful data due to limited accesses.
%
With large cache size, algorithms can catch marginal accesses.
%
Most of equal hotness counters come from repeated accesses in a sequence, and prefetchers can help to catch them.
%



\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{fig/overview.drawio.pdf}
    \caption{Overview for \sys. Cache space consists of five parts: filter cache, main cache, suspicious cache, ghost cache, and CBF. The workflow has three major parts, (1)cache promotion and eviction in four sub-cache. (2)IA-MP objects in the filter cache duels with the tail object in the suspicious cache with CBF. (3)Leverage the metadata in the ghost cache to find FA-FP objects and prefetch sequence accessed objects.\TODO{update}}
    \label{fig:overview}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{fig/phaseflow.drawio.pdf}
    \caption{\sys consists of two epoch flows.(1)Frequently accessed objects' movement from the main cache to the suspicious cache and reinsertion to the main cache. (2)Infrequently accessed objects' movement from the filter cache to the ghost cache. Objects' type changes with suspection in the filter and ghost cache.\TODO{update}}
    \label{fig:epochflow}
\end{figure}
