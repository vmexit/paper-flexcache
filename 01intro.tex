\section{Introduction}
\label{s:intro}
Software caches, e.g., Memcached~\cite{}, Redis~\cite{}, and Linux page cache~\cite{}, are widely adapted in various fields to improve the service performance.
%
For the cache to work in a variety of scenarios, it should be 
%
(1) \textit{reliable}: whatever the workload and cache size are, the cache should keep a high hit ratio for short latencies; 
%
(2) \textit{efficient}: it should manage data in the cache space effectively for high throughput; and 
%
(3) \textit{scalable}: the ability to handle data requests can scale with the increase of the number of CPU cores and the cache size.
%
Cache eviction algorithm is the core component for a cache to achieve the reliability, efficiency, and scalability.

To design a reliable cache eviction algorithm, prior work analyses the access patterns of workloads~\cite{} and proposes non-adaptive~\cite{} and adaptive~\cite{} algorithms to handle them.
%
There are four typical primitive access patterns: \textit{LRU-friendly}, \textit{LFU-friendly}, \textit{Scan}, and \XXX{\textit{Churn}}~\cite{}.
%
A non-adaptive algorithm~\cite{} consistently leverages a fixed criterion and workflow to manage one or part of access patterns;
%
while an adaptive algorithm~\cite{} adjusts the operation or cache size for the data in different patterns.

Adaptive algorithms promise to improve caching performance, but existing adaptive algorithms are inefficient to a degree that underperforms non-adaptive algorithms.
%
S3FIFO~\cite{} is a typical non-adaptive algorithm which focuses on the \textit{Scan} pattern, also known as one-hit wonders.
%
It does not change its behavior whatever the accesses are, and outperforms SOTA algorithms about 3\% in KV and CDN benchmarks~\cite{}.
%
What's more, S3FIFO has a high throughput close to Segcache~\cite{} and achieves a high scalability with 16 cores.

Adaptive algorithms failed to cover the full spectrum of access patterns, for their designs are based on linear interpolation.
%
There are two types of adaptive algorithms: \textit{spatial adaptive} algorithm~\cite{} and \textit{temporal adaptive} algorithm~\cite{}.
%
Spatial adaptive algorithms separate data into two access patterns and manage them using an adjustable cache size to exploit spatial locality, which adjust for the mixture of two patterns.
%
Temporal adaptive algorithms leverage two basic policies for different primitive access patterns, and invoke them with different probabilities to catch the temporal locality.
%
They adjust between two basic policies, and what's more, if a basic policy targets more than one primitive access pattern, the two basic policies will interfere with each other.
%

To preserve a high cache hit rate in various complex access patterns, our {\textit{key insight}} is that \textbf{To be effective, a cache eviction algorithm should cover all contiguous space of access patterns, rather than linear interpolation between access patterns as done in prior work.} 
%
As shown in figure~\ref{fig:insight}, spatial adaptive algorithms target for the frequency and recency based data, which is a linear interpolation between \textit{LRU-friendly} and \textit{LFU-friendly} patterns.
%
Temporal adaptive algorithms invoke LRU-Scan-Resistant policy and LFU-Churn-Resistant policy with probabilities, which is two linear interpolations implemented in different time.
%
The phase and frequency-based classification can cover all four typical primitive access patterns and catch the mixed parts to cover the contiguous space.  

\TODO{figure for insight\label{fig:insight}}

We propose a hotness and phase-based type classification, which covers all four typical primitive access patterns. 
\TODO{support the key insight}


\begin{figure}[t]
\centering
\input{data/cachesize}
\caption{Replacement policies' performance in Cloudphysics.\TODO{update figure}}
\label{fig:cloudphysics}
\end{figure}

\begin{figure}[t]
    \centering
    \input{data/mrcdemo}
    \caption{Miss ratio curves and relative performance in systor.}
    \label{fig:mrcdemo}
\end{figure}


This performance degradation is caused by the limitations of access pattern classification and cache design.
%
The access pattern classification does not take cache size into account, causing the same access pattern to be classified into different categories under different cache sizes~(\autoref{ss:access-patterns}).
%
Cache replacement policies, when performing adaptive adjustments, 
\DZ{Vague term, unclear what it means.}
\XXX{also fail to consider global access information comprehensively~(\autoref{ss:adaption-criteria}).}
%
This leads to design flaws in the adjustment mechanism, resulting in extremely poor performance in certain scenarios.
%
In some policies, as the cache size increases, the hit ratio actually worsens\TODO{figure}.

This paper explores the relationship between access patterns and cache size and proposes \sys, a phase-aware and cache-size-aware replacement policy that can adapt to different access patterns and cache sizes.
%
\DZ{We need one insight, not three. Less is more. Which prior paper we read proposes three insights?
}
We design \sys based on \XXX{three \textit{insights}}:
%
First, splitting the access trace into phases according to the cache size is a method for cache-size-aware.
%
Second, to classify the object type dynamically, we consider the access frequency distribution in different phases.
%
Third, the policy should consider the overall cache access behavior to adapt to mixed access patterns.

\TODO{\sys}

\TODO{performance}

In summary, we make the following contributions:
\squishlist
\item{\textbf{todo.}}
\squishend
%