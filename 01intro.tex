\section{Introduction}
\label{s:intro}
Software caches, e.g., Memcached~\cite{}, Redis~\cite{}, and the Linux page cache~\cite{}, are widely adopted across various fields to improve service performance.
%
For the cache to work in a variety of scenarios, it should be 
%
(1) \textit{reliable}: whatever the workload and cache size are, the cache should keep a high hit ratio for short latencies; 
%
(2) \textit{efficient}: it should manage data in the cache space effectively for low bandwith consumption and high throughput; and 
%
(3) \textit{scalable}: the ability to handle data requests can scale with the increase in the number of CPU cores and the cache size.
%
The cache eviction algorithm is the core component for a cache to achieve reliability, efficiency, and scalability.

To design a reliable cache eviction algorithm, prior work analyzes workload access patterns~\cite{} and proposes non-adaptive~\cite{} and adaptive~\cite{} algorithms to handle them.
%
There are four typical primitive access patterns: \textit{LFU-friendly}, \textit{LRU-friendly}, \XXX{\textit{Churn}}, and \textit{Scan}~\cite{}.
%
A non-adaptive algorithm~\cite{} makes a predefined assumption about access distribution and consistently leverages a fixed criterion and workflow to manage one or part of target access patterns; 
%
while an adaptive algorithm~\cite{} adjusts the operation or cache size for the data in different patterns.

Adaptive algorithms promise to improve caching performance, but existing adaptive algorithms are inefficient to a degree that underperforms non-adaptive algorithms.
%
S3FIFO~\cite{} is a typical non-adaptive algorithm which focuses on the \textit{Scan} pattern, also known as one-hit wonders.
%
It does not change its behavior, regardless of the accesses, and outperforms SOTA algorithms by about 3\% in KV and CDN benchmarks~\cite{}.
%
What is more, S3FIFO has a high throughput close to Segcache~\cite{} and achieves a high scalability with 16 cores.
%
As shown in figure~\ref{fig:cloudphysics}, non-adaptive algorithms, e.g., S3FIFO and WTinyLFU~\cite{}, outperform adaptive algorithms, e.g., ARC~\cite{}, in small and large cache sizes separately.

Prior adaptive algorithms failed to cover the full spectrum of access patterns because they rely on two interpolated discrete patterns.
%
There are two types of adaptive algorithms: \textit{spatial adaptive} algorithm~\cite{} and \textit{temporal adaptive} algorithm~\cite{}.
%
Spatial adaptive algorithms separate data into two access patterns and manage them using an adjustable cache size to exploit spatial locality, adjusting to the mixture of the two patterns.
%
Temporal adaptive algorithms leverage two basic policies for different primitive access patterns and invoke them with different probabilities to exploit temporal locality.
%
They alternate between two basic policies, and, what is more, if a basic policy targets more than one primitive access pattern, the two policies will duel and interfere with each other.
%

To preserve a high cache hit rate in various complex access patterns, our {\textit{key insight}} is that \textbf{To be effective, a cache eviction algorithm should cover all contiguous space of access patterns by phase and hotness adaption, rather than interpolation between discrete access patterns as done in prior work.} 
%
As shown in figure~\ref{fig:insight}, spatial adaptive algorithms target frequency- and recency-based data, which lies between \textit{LRU-friendly} and \textit{LFU-friendly} patterns.
%
Temporal adaptive algorithms invoke the LRU-Scan-Resistant and LFU-Churn-Resistant policies with probabilities, which are two interpolated policies implemented at different times.
%
The phase- and hotness-based classification can cover all four typical primitive access patterns and reveals how different types transform from one to another, thus capturing the mixed parts to fill the contiguous space. 

\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{fig/type.drawio.pdf}
\caption{Typical primitive access patterns and coverage of existing adaptive algorithms and \sys.}
\label{fig:insight}
\end{figure}

This paper proposes a phase- and hotness-based type classification that covers all four typical primitive access patterns. 
%
According to the number of phases in which the data appears, it can be categorized as persistent or ephemeral.
%
Based on access hotness, data is either frequently or infrequently accessed.
%
The four basic types are therefore: \textit{frequent-persistent}, \textit{frequent-ephemeral}, \textit{infrequent-persistent}, and \textit{infrequent-ephemeral}.
%
With an appropriate phase size, an \textit{LFU-friendly} pattern appears frequently as \textit{frequent-persistent} type, and an \textit{LRU-friendly} pattern has a small reuse distance as \textit{frequent-ephemeral} type.
%
A \textit{Churn} pattern repeats in many phases as \textit{infrequent-persistent} type, and a \textit{Scan} pattern appears only once as \textit{infrequent-ephemeral} type. 
%
As shown in figure~\ref{fig:insight}, new primitive types reveal the relationship between primitive access patterns and thus cover the contiguous space of access patterns.

Based on characterization of types, this paper proposes \sys, a reliable, efficient, and scalable cache eviction algorithm.
%
\sys uses a small queue to filter out \textit{infrequent-ephemeral} data, a ghost queue with only metadata to track \textit{frequent-ephemeral} data, and a sketch recording the number of phases \textit{infrequent-persistent} data appears with a forget function.
%
Since data types will change from one to another and \textit{frequent-persistent} requires a long time observation, \sys uses a suspicious queue to check and confirm the type of data and holds data to be cached in a main queue, which consumes most of the cache space.
%
\sys observes data at least a phase, so all the queues are FIFO-based, where data is evicted by the ghost queue or checked by the suspicious queue coming from the main queue for a phase.
%
\sys records the access frequency distribution of all data in the cache to adjust the criteria for frequent and infrequent data.

\sys is reliable in various situations.
%
We compare \sys with \XXX{16} eviction algorithms on \XXX{11} real-world benchmarks, including KV, CDN, and block workloads.
%
A \textit{dominant algorithm} outperforms all the other algorithms on a trace with a specific cache size.
%
\sys is the dominant algorithm on \XXX{}\% of all the \XXX{} traces in workloads with different cache sizes.
%
\sys also achieves \XXX{}\% of the dominant algorithm in \XXX{}\% traces.
%
As a comparison, the next-best algorithm is \XXX{}, which is the dominant algorithm on \XXX{}\% of all traces and achieves \XXX{}\% of the dominant algorithm in \XXX{}\% of the traces.

\sys is also efficient and scalable because FIFO queues and the sketch enable lock-free implementations.
%
We implemented a prototype of \sys in Cachelib~\cite{} and show that \sys achieves \TODO{more details}.

\begin{figure}[t]
\centering
\input{data/cachesize}
\caption{Replacement policies' performance in Cloudphysics.\TODO{update figure with adaptive algorithms}}
\label{fig:cloudphysics}
\end{figure}

\begin{figure}[t]
    \centering
    \input{data/mrcdemo}
    \caption{Miss ratio curves and relative performance in systor.}
    \label{fig:mrcdemo}
\end{figure}

In summary, this work makes the following contributions:
\squishlist
\item{{\textbf{Phase and hotness-based type classification}, which comprehensively characterizes primitive access patterns and reveals the relationship between them.}}
\item{{\textbf{\sys}. Based on the new classification, we design \sys, a reliable cache eviction algorithm, which dominates across diverse workloads.}}
\item{{\textbf{Efficiency and scalability}. We implement a prototype of \sys in Cachelib and demonstrate its efficiency and scalability.\TODO{more details}}}
\squishend
%