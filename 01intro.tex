\section{Introduction}
\label{s:intro}
Software caches, e.g., Memcached~\cite{}, Redis~\cite{}, and Linux page cache~\cite{}, are widely adapted in various fields to improve the service performance.
%
For the cache to work in a variety of scenarios, it should be 
%
(1) \textit{reliable}: whatever the workload and cache size are, the cache should keep a high hit ratio for short latencies; 
%
(2) \textit{efficient}: it should manage data in the cache space effectively for high throughput; and 
%
(3) \textit{scalable}: the ability to handle data requests can scale with the increase of the number of CPU cores and the cache size.
%
Cache eviction algorithm is the core component for a cache to achieve the reliability, efficiency, and scalability.

To design a reliable cache eviction algorithm, prior work analyses the access patterns of workloads~\cite{} and proposes non-adaptive~\cite{} and adaptive~\cite{} algorithms to handle them.
%
There are four typical primitive access patterns: \textit{LFU-friendly}, \textit{LRU-friendly}, \XXX{\textit{Churn}}, and \textit{Scan}~\cite{}.
%
A non-adaptive algorithm~\cite{} consistently leverages a fixed criterion and workflow to manage one or part of access patterns;
%
while an adaptive algorithm~\cite{} adjusts the operation or cache size for the data in different patterns.

Adaptive algorithms promise to improve caching performance, but existing adaptive algorithms are inefficient to a degree that underperforms non-adaptive algorithms.
%
S3FIFO~\cite{} is a typical non-adaptive algorithm which focuses on the \textit{Scan} pattern, also known as one-hit wonders.
%
It does not change its behavior whatever the accesses are, and outperforms SOTA algorithms about 3\% in KV and CDN benchmarks~\cite{}.
%
What's more, S3FIFO has a high throughput close to Segcache~\cite{} and achieves a high scalability with 16 cores.
%
As shown in figure~\ref{fig:cloudphysics}, non-adaptive algorithms, e.g., S3FIFO and WTinyLFU~\cite{}, outperform adaptive algorithms, e.g., ARC~\cite{} in small and large cache sizes separately.

Adaptive algorithms failed to cover the full spectrum of access patterns, for their designs are based on linear interpolation.
%
There are two types of adaptive algorithms: \textit{spatial adaptive} algorithm~\cite{} and \textit{temporal adaptive} algorithm~\cite{}.
%
Spatial adaptive algorithms separate data into two access patterns and manage them using an adjustable cache size to exploit spatial locality, which adjust for the mixture of two patterns.
%
Temporal adaptive algorithms leverage two basic policies for different primitive access patterns, and invoke them with different probabilities to catch the temporal locality.
%
They adjust between two basic policies, and what's more, if a basic policy targets more than one primitive access pattern, the two basic policies will interfere with each other.
%

To preserve a high cache hit rate in various complex access patterns, our {\textit{key insight}} is that \textbf{To be effective, a cache eviction algorithm should cover all contiguous space of access patterns, rather than linear interpolation between access patterns as done in prior work.} 
%
As shown in figure~\ref{fig:insight}, spatial adaptive algorithms target for the frequency and recency based data, which is a linear interpolation between \textit{LRU-friendly} and \textit{LFU-friendly} patterns.
%
Temporal adaptive algorithms invoke LRU-Scan-Resistant policy and LFU-Churn-Resistant policy with probabilities, which is two linear interpolations implemented in different time.
%
The phase and frequency-based classification can cover all four typical primitive access patterns and catch the mixed parts to cover the contiguous space.  

\TODO{figure for insight\label{fig:insight}}

This paper proposes a hotness and phase-based type classification, which covers all four typical primitive access patterns. 
%
Based on access frequency, data is either frequently or infrequently accessed.
%
According to the number of phases in which the data appears, it can be categorized as persistent or ephemeral.
%
The four basic types are therefore: \textit{frequent-persistent}, \textit{frequent-ephemeral}, \textit{infrequent-persistent}, and \textit{infrequent-ephemeral}.
%
With an appropriate phase size, an \textit{LFU-friendly} pattern appears frequently as \textit{frequent-persistent} type, and an \textit{LRU-friendly} pattern has a small reuse distance as \textit{frequent-ephemeral} type.
%
A \textit{Churn} pattern repeats in many phases as \textit{infrequent-persistent} type, and a \textit{Scan} pattern appears only once as \textit{infrequent-ephemeral} type. 
%
As shown in figure~\ref{fig:insight}, new primitive types reveal the relationship between primitive access patterns, and thus cover the contiguous space of access patterns.

Based on characterization of types, this paper proposes \sys, a reliable, efficient, and scalable cache eviction algorithm.
%
\sys uses a small queue to filter out \textit{infrequent-ephemeral} data, a ghost queue with only metadata to track \textit{frequent-ephemeral} data, and a sketch recording the number of phases \textit{infrequent-persistent} data appears with a forget function.
%
Since data types will change from one to another and \textit{frequent-persistent} requires a long time observation, \sys uses a suspicious queue to check and confirm the type of data and holds data to be cached in a main queue, which consumes most of the cache space.
%
\sys observes data at least a phase, so all the queues are FIFO queues, where data is evicted by the ghost queue or checked by the suspicious queue coming from the main queue for a phase.
%
\sys records the access frequency distribution of all the data in the cache to adjust the criterion of frequent and infrequent data.

\sys is reliable in various situlations.
%
We compare \sys with \XXX{16} eviction algorithms on \XXX{11} real-world benchmarks, including KV, CDN, and block workloads.
%
A \textit{dominant algorithm} outperforms all the other algorithms on a traces with a specific cache size.
%
\sys is the dominant algorithm on \XXX{}\% of all the \XXX{} traces in workloads with different cache sizes.
%
\sys also achieves \XXX{}\% of the dominant algorithm in \XXX{}\% traces.
%
As a comparision, the next best algorithm is \XXX{}, which is the dominant algorithm on \XXX{}\% of all the traces and achieves \XXX{}\% of the dominant algorithm in \XXX{}\% traces.

\sys is also efficient and scalable because FIFO queues and sketch enable lock-free implementations.
%
We implemented a prototype of \sys in Cachelib~\cite{} and show that \sys achieves \TODO{}.

\begin{figure}[t]
\centering
\input{data/cachesize}
\caption{Replacement policies' performance in Cloudphysics.\TODO{update figure with adaptive algorithms}}
\label{fig:cloudphysics}
\end{figure}

\begin{figure}[t]
    \centering
    \input{data/mrcdemo}
    \caption{Miss ratio curves and relative performance in systor.}
    \label{fig:mrcdemo}
\end{figure}

In summary, this work makes the following contributions:
\squishlist
\item{{We propose a new hotness and phase-based type classification, which comprehensively characterizes primitive access patterns and reveals the relationship between them.}}
\item{{Based on the new classification, we design \sys, a reliable cache eviction algorithm, which dominates across diverse workloads.}}
\item{{We implement a prototype of \sys in Cachelib and demonstrate its efficiency and scalability.}}
\squishend
%