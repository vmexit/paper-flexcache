\section{Background and Motivation}
\label{s:background}
This section provides background on classical access patterns~\cite{}~(\autoref{ss:access-pattern-based-analysis}) and on how prior work designs algorithms to cover them, both non-adaptively~\cite{} and adaptively~\cite{}~(\autoref{ss:non-adaptive-and-adaptive-algorithms}). However, the real-world access is much complex than ideal access patterns. We observe that most eviction algorithms operate in a metastable state, leading to a significant decrease in hit ratio for some benchmarks and configurations~(\autoref{ss:the-metastable-phenomenon}).

\subsection{Access pattern-based analysis}
\label{ss:access-pattern-based-analysis}
Many work analyzes access streams based on metrics to classify them into specific access patterns~\cite{}. 
%
The locality of accesses is an intrinsic property of workloads, which reveals the potential for caching.
%
The temporal locality focuses on the time interval between two accesses to the same object, which is typically measured by the reuse distance~\cite{}.
%
The spatial locality concentrates on the correlation between accesses to different objects, (\eg, adjacent accesses and adjacent addresses)~\cite{}.
%
A frequency-based analysis checks whether the access frequency distribution follows a specific distribution, (\eg, Zipfian distribution)~\cite{}.
%
On the other hand, some work againsts inference accesses, which deviates from the typical access patterns~\cite{}.
%
To deal with real-world behaviors, some work analyzes the daily or long time periodicity of accesses~\cite{}, but this paper discusses the logical access only.
%
Based on the above metrics, there are four typical primitive access patterns: \textit{LFU-friendly}, \textit{LRU-friendly}, \textit{Churn}, and \textit{Scan}~\cite{}.

\textbf{An LFU-friendly pattern} has a skewed access frequency distribution, where a small portion of objects are accessed frequently, and most objects are accessed infrequently.
%
The \textit{LFU} eviction algorithm is the best choice for this pattern, which keeps the frequently accessed objects in the cache and evicts the infrequently accessed ones.

\textbf{An LRU-friendly pattern} has good temporal locality with a small reuse distance, where the recently accessed objects are likely to be accessed again soon.
%
The \textit{LRU} eviction algorithm is the best choice for this pattern, which keeps the recently accessed objects in the cache and evicts the least recently used ones.

\textbf{A \XXX{Churn} pattern} is a set of repeated accesses, where all objects are accessed with equal probability~\cite{}.

\textbf{A Scan pattern} is a set of accesses where all objects are accessed only once, which means it is an interference with no reuse.

However, prior work cannot separate a workload into the above four primitive access patterns perfectly.
%
Most workloads are a mixture of the above primitive access patterns, and the mixture is complex.
%
Some of them are a combination of two or more primitive access patterns, and some of them are not similar to any primitive access patterns.

\subsection{Non-adaptive and adaptive algorithms}
\label{ss:non-adaptive-and-adaptive-algorithms}
Guided by access patterns, an algorithm either covers them statically or adapts to them. 
%
An adaptive algorithm will adjust the operation or cache size for data in different patterns, whereas a non-adaptive algorithm consistently uses a fixed criterion and workflow. 
%
However, adaptive algorithms are not the best choice for various patterns, and a non-adaptive algorithm, S3FIFO, outperforms them in many workloads.

Non-adaptive algorithms make a predefined assumption about access distribution and mainly filter a major access pattern from interference patterns.
%
Deviated from the LRU algorithm, SLRU~\cite{} changes the insertion point to filter out the \textit{Scan} pattern from the \textit{LRU-friendly} pattern.
%
As an algorithm that focuses more on access frequency, WTinyLFU~\cite{} uses a Count-Min Sketch~\cite{} to record long-term access counts for \textit{LFU-friendly} pattern.
%
2Q~\cite{} separates the first access and subsequent accesses to filter out the \textit{Scan} pattern, and S3FIFO~\cite{} leverage three FIFO queues to quickly demote \textit{Scan} pattern.
%
Hyperbolic~\cite{}, LHD~\cite{}, and GDSF~\cite{} consider both access frequency and recency with a new metric to cover both \textit{LFU-friendly} and \textit{LRU-friendly} patterns.
%
With the fixed criterion metric and workflow, these non-adaptive algorithms are reliable in specific access patterns.

Adaptive algorithms adjust the subpart size for patterns or the criterion metric for spatial or temporal adaptive. 
%
Spatial adaptive algorithms, ARC~\cite{} and CAR~\cite{}, separate data into recency and frequency parts, which means \textit{LRU-friendly} and \textit{LFU-friendly} patterns.
%
Then, they use two ghost caches with only metadata for the marginal hit ratios to guide the adjustment of the two parts.
%
Temporal adaptive algorithms, LeCaR~\cite{} and Cacheus~\cite{}, propose a framework, which leverages two basic policies and invokes them with different probabilities.
%
LeCaR uses LRU and LFU as two basic policies, and Cacheus uses LRU-Scan-Resistant and LFU-Churn-Resistant as two basic policies.
%
However, adaptive algorithms cannot separate primitive access patterns perfectly in either spatial or temporal dimensions, which incurs a great overhead in the framework.

\subsection{The metastable phenomenon}
\label{ss:the-metastable-phenomenon}
SOTA algorithms are metastable in many benchmarks, which means that they perform poorly in some workloads.
%
First, we evaluate algorithms in many workloads with different cache sizes and select the algorithm with the highest hit rate in each configuration as the \textbf{dominant algorithm}.
%
Then, we calculate the relative hit ratio to the dominant algorithm for each algorithm.
%
Finally, we group the results by cache size or workload and form CDFs to show the metastable phenomenon.
%
For a workload, the dominant algorithm changes with the cache size.
%
What is more, there are more than \XXX{10\%} of workloads that lose more than \XXX{20\%} performance with a specific algorithm for a given cache size.

The metastable phenomenon of cache eviction algorithms poses a challenge for cache deployment.
%
As shown in figure~\ref{fig:cloudphysics}, when an administrator deploys a single algorithm, about 10\% of workloads tend to have more than 20\% performance loss than expected dominant algorithm.
%
As the cache size changes, the dominant algorithm gradually shifts.
%
Keeping the same eviction algorithm under such changes prevents full utilization of system performance, while using multiple eviction algorithms simultaneously increases management complexity.
\TODO{details}

\textbf{Non-adaptive algorithms} are limited by their design space. 
%
They makes a predefined assumption about access distribution and work well in specific access patterns.
%
However, the filtering mechanism will make wrong decisions in complex access patterns, failed to cover the full spectrum of access patterns.
%
S3FIFO~\cite{} filters out \textit{Scan} pattern, also one-hit wonders, from other patterns, and outperforms others in a small cache size for KV and CDN benchmarks~\cite{}.
%
While a large cache size and block access benchmarks~\cite{} has less one-hit wonders, S3FIFO evicts \textit{infrequent-ephemeral} data, leading to a significant performance degradation.
%

\textbf{Spatial adaptive algorithms} are influenced by changed access patterns. 
%
ARC~\cite{} and CAR~\cite{} separate data into recency and frequency parts, and pattern transition happens only once from recency to frequency.
%
When the access pattern changes, it takes time to evict old data and adjust the part size.
%
To rebalance the marginal hit ratios, they always make a wrong decision, leading to a low hit ratio even with a large cache size.
%
The one-side transition framework explores only a part of interpolation between \textit{LRU-friendly} and \textit{LFU-friendly} patterns.

\textbf{Temporal adaptive algorithms} suffer from a conflict of sub-policies. 
%
CACHEUS~\cite{} and LeCaR~\cite{} invoke two basic policies with different probabilities to cover the design scopes of each base policy.
%
However, in practice, probabilistic invocation can only account for one policy's design scope at a time, leading to a sub-optimal result. 
%
Moreover, under such a framework, policy A may evict the data that policy B focuses on, and the confliction breaks the originally intended interpolated space.