\section{Background}
\label{s:background}
Software caches are wildly implemented in various fields to handle different access patterns, but their adaptability to mixed access patterns are limited.
%
In the KV-store, CDN, and memory devices, the cache stores Key-Value pairs, web objects, and data blocks, respectively, and we use the term \textit{object} to represent the data unit stored in the cache.
%
We have many tools to analyze the benchmkars, determine the access pattern, and design the best cache replacement policy for a specific cache size. 
%
This section introduces the basic access patterns~(\S\ref{ss:access-patterns}) and how prior work designs the cache replacement policy for them~(\autoref{ss:adaption-criteria}).

\subsection{Access patterns}
\label{ss:access-patterns}
Prior work classifies the access patterns into four basic types and a mixture of the basic types. 
%
This classification method is very intuitive, but we can determine the trace type only after the analysis (e.g., implementing the replacement policy).

\textbf{LRU-friendly} is a set of access that the \cc{least recently used} (LRU) replacement policy is the best choice.

\textbf{LFU-friendly} is a set of access that the \cc{least frequently used} (LFU) replacement policy is the best choice.

\textbf{Scan} is a set of access that all objects are accessed only once, which means no replacement policy can deal with it.

\textbf{Period repeated access} is a set of repeated accesses, and a more restrictive definition is that the objects are accessed with equal probability~\cite{}(cacheus), which means the hit ratio is related to the cache size. If the cache size is larger than the repeated objects, the hit ratio is 100\%, and if the cache size is smaller than the repeated objects, the hit ratio is a fixed number.

%\textbf{Mixture of the basic types} \dots
%This classification method is neither object-based nor access sequence-based, but only for the trace type.
This classification method cannot tell us the object type, only the trace type, and even if the cache size changes, the trace type will change.
%so defining a mixture of the basic types is confusing. 
%
If an object is accessed many times in a short sequence, without access for a long sequence, and then reaccessed, we cannot determine whether it is LRU-friendly or LFU-friendly. 
%
If the footprint of the long access sequence is smaller than the cache size, is the object both LRU-friendly and LFU-friendly? 
%
This classification method is retrospective â€” the first access to each object is treated as part of a scan, and only after the second access can the object be classified as another type.
%
For trace $\text{AAAABBCCCDDCCA}$, if the cache size is 2, the base policy is LRU, so it is LRU-friendly, but if the cache size is 3, the base policy is LFU, so it is LFU-friendly.
%

\textbf{Summary: We need a method to classify the object type with cache size awareness.}


\subsection{Adaption for mixed access patterns}
\label{ss:adaption-criteria}
Prior work splits the cache into different parts to handle access patterns or filter interference between them.
%
They commonly split the cache into three functional parts: \cc{the main cache}, \cc{the filter cache}, and \cc{the ghost cache}.
%
If the access patterns are a major pattern and an interference pattern, the main cache stores the major pattern, and the filter cache filters the interference pattern.
%
If there are two major patterns, they split the main cache into two parts, one for each major pattern. 
%
Many policies use the ghost cache to store the metadata of the evicted objects~\cite{}, which can be used to adjust the size of other parts.
%The miss records in the ghost cache can help adjust the size of the main cache and filter cache.
The access patterns in (\S\ref{ss:access-patterns}) and incomplete criteria for adjustment mechanisms limit the capability of the replacement policy.

%They change the part size according to the hit information and tag the object type with static criteria.

\textbf{The major pattern and interference pattern.} In order to filter scan in the LRU-friendly pattern, SLRU~\cite{} adds the new object to the filter cache and promotes it to the main cache if it is reaccessed.
%
LIRS~\cite{} uses the ghost cache to identify the recently accessed objects and promotes them to the main cache if they are reaccessed.
%
In order to filter period repeated access in the LFU-friendly pattern, MQ~\cite{} splits the cache into many parts to store the objects with different access frequencies and evicts the object with the lowest access frequency.
%
TinyLFU~\cite{} uses the filter part to record the access frequency, and only those with high access frequency are admitted into the main cache.
%
S3-FIFO~\cite{} analyzes the access pattern and finds that most benchmarks consist of many scan accesses (named One-hit-wonder), so it uses a small filter cache to decrease newly accessed objects and a ghost cache to pick up the wrongly evicted objects.
% 

\textbf{Dueling for two major patterns.} Others think that the replacement policy should adapt to the access pattern, so they design the policy to cover both LRU-friendly and LFU-friendly patterns.
%
LeCaR~\cite{} and Cacheus~\cite{} leverage two major replacement policies (e.g., LRU and LFU) and adjust the probability of applying each policy based on the hit information collected from the ghost cache.
%
2Q~\cite{}, ARC~\cite{} and CAR~\cite{} consider that the first access to objects and subsequent accesses exhibit different patterns, and therefore we need to manage them separately. 
%
They use ghost caches to adjust the proportion of different types of objects accordingly.
%Dueling for LRU-friendly and LFU-friendly. ARC, CAR, 2Q,LeCaR,Cacheus,LRFU

These policies based on basic access patterns are insufficient and suffer from severe performance degradation.% different access pattern. 
%
First, basic access patterns are unaware of the cache size, causing the replacement policy's performance to fluctuate significantly as the cache size changes. 
%
(\TODO{figure} )
%
Second, they are too positive to the objects in the filter cache and ghost cache, leading to misjudgment about the overall access behavior. 
%relying solely on the objects in the ghost cache may lead to misjudgments about the overall access behavior.
%
If a request hits the ghost cache, these policies increase the cache size of the corresponding pattern or the usage probability of the competing pattern as compensation.
%
What's more, these policies do not account for hits in the main cache, in ARC and CAR, many objects that are accessed only twice consecutively can cause cache pollution by evicting important objects from the main cache.
%
We will discuss it in (\S\ref{ss:split-trace}). 

\textbf{Summary:We need to take the overall cache access behavior into account to adapt to mixed access patterns.}


